## 3.1 코드의 나쁜 냄새란 ?

- Bad Smells in Code

  - 냄새 나면 당장 갈아라

  - 코드에서 나쁜 냄새가 나면 리팩토링할 시간

- 당신은 당신이 뭘 모르는지 모른다

  - 어떤 코드가 나쁜 코드인지 모르면,

  - 어떻게 개선 해야 하는지도 모른다

- 그래서 이번 챕터에서는 나쁜 코드에 대해서 배운다

## 3.2 나쁜 냄새 (기본적인 악취)

<img src='./images/ch03/01.png'>

- 기이한 이름 (Mysterious Name)

  - 코드 이해력과 가독성을 떨어뜨린다

  - 악취 중에서도 가장 나쁜 악취

  - 좋은 이름은 좋은 프로그래밍의 시작

- 중복 코드 (Duplicated Code)

  - 실수와 에러 발생할 확률 높아 진다

- 긴 함수 (Long Function)

  - 이해하기 어렵다

  - 재활용성이 떨어진다

- 긴 매개변수 목록 (Long Parameter List)

  - 사용하기 어렵다

  - 잦은 실수

- 전역 데이터 (Global Data)

  - 가장 최악이다

  - 유령같은 버그가 출몰할 수 있다

- 가변 데이터 (Mutable Data)

  - 예상하지 못한 곳에서 데이터를 변경할 수 있다

## 3.3 나쁜 냄새2 (고급 레벨)

<img src='./images/ch03/02.png'>

- 뒤엉킨 변경 (Divergent Change)

  - 한 모듈 안에서 다양한 일을 하게 되면

  - 모듈 내에서 한 부분을 수정하면 다른 부분에서 또 업데이트를 해야 한다

  - 다양한 이유로 수정을 해야 한다

  - 즉, 한 곳에서 지나치게 많은 일을 하지 않도록 한다

- 산탄총 수술 (Shotgun Surgery)

  - 한 모듈을 수정하면, 이 모듈이 다른 모듈과 너무 커플링 되어 있어서

  - 한 모듈을 수정하면 내부 수정이 외부에 있는 모듈과 연관되어 다른 곳에서도 수정을 해야 하는 경우를 말한다

  - 여러 곳에서 수정해야 한다

- 기능 편애 (Feature Envy)

  - 내부적으로 응집도가 있지 않고

  - 다른 모듈과 더 밀접하게 상호작용하는 경우이다

- 이러한 악취들은 각각의 악취가 아니라 서로 연관되어 있는 악취이다

- 데이터 뭉치 (Data Clumps)

  - 서로 연관있는 데이터라서 이것들을 하나로 객체로 뭉쳐서 여기 저기 전달하면,

  - 데이터를 처리하기 위한 로직들이 따로 있을텐데, 이런 로직들도 따로따로 여기저기 뭉쳐있을 수 있다

  - 그래서 데이터끼리 뭉쳐다니는 경우에 나쁜 냄새임을 인지하고, 이 데이터를 가지고 어떤 처리를 다른곳에서 하는지 알아볼 필요가 있다

- 기본형 집착 (Primitive Obsession)

  - 데이터 뭉치와 기본형 집착은 비슷한 악취

  - 데이터와 기본형을 처리하기 위한 관련된 코드가 여기저기 있다면 한 곳에 묶어서 처리하는 것이 중요하다

  - 순수 데이터와 기본형에 집착하지 말고 관련된 데이터를가 있다면 하나로 묶어주는 것이 좋다

  - 즉, 데이터나 기본형을 처리하기 위한 로직이 여기저기 있다면 나쁜 냄새가 나는 것이다

- 반복되는 Switch 문 (Repeated Switches)

  - Switch 문에서 타입을 확인하기 위한 코드가 여기저기 있다면

  - 새로운 타입이 추가되면 여기저기 업데이트 해야 한다

  - 이는 다형성을 사용해서 해결하는게 좋다

## 3.4 나쁜 냄새3 (기타 냄새들)

<img src='./images/ch03/03.png'>

- 반복문 (Loops)

  - 절차형의 코드는 사이드 이펙트를 발생시킬 수 있다

- 성의 없는 요소 (Lazy Element)

  - 불필요한 함수, 클래스, 인터페이스

- 추측성 일반화 (Speculative Generality)

  - 혹시 모르니 미래를 위해서 남겨 놓는 것

- 임시 필드 (Temporary Field)

  - 임시 필드를 여기저기 사용하면 코드를 읽어나가면서 흐름이 끊기는 일이 발생한다

  - 이해도를 떨어뜨린다

    - 되도록 사용하지 않는다

- 메세지 체인 (Message Chains)

  - 코드 끝나면 다른 코드가 실행되고 ..

  - 이걸하고 결과 값이 나오면, 이걸 하고 ...

  - 이런 식으로 순차적으로 발생하도록 코드를 작성하는 것

  - 너무 내부 로직이 외부로 노출된다

  - 사용하는 곳 마다 순차적으로 사용해야 하는 불상사가 발생

  - 개발자가 나도 모르게 순서를 바꿔서 에러가 발생할 수 있다

- 중개자 (Middle Man)

  - 내가 클래스에 있는 함수를 호출했더니

  - 클래스 내부에서 특정 로직을 처리하는 것이 아니라 다른 클래스 함수를 호출하는 식으로

  - 즉 호출만하는, 중개자 역할만 한다면 해당 클래스가 필요한지 생각해 볼 필요가 있다

  - 단순 전달만 하는 불필요한 코드

<img src='./images/ch03/04.png'>

- 내부자 거래 (Insider Trading)

  - 내 모듈 내부에서 특정한 함수가 너무 외부에 있는 모듈을 참조하거나 호출하거나 너무 의존하는 경우

  - 모듈 간의 결합도가 높아지기 때문에 이것도 악취 중에 하나

  - 모듈 사이의 데이터 거래를 하면 결합도가 높아질 수 있다

- 거대한 클래스 (Large Class)

  - 중복 코드가 증가할 수 있고

  - 뒤엉킨 변경의 악취가 날 수 있다

- 서로 다른 인터페이스의 대안 클래스들 (Alternative Classes with Different Interfaces)

  - 비슷한 일을 하는데 호출하는 방식이 다른 경우

  - 서로 대체성이 떨어지기 때문에 재사용성이 떨어진다

  - 즉 비슷한 일을 하는데 인터페이스가 다르다면 나쁜 냄새가 나는 것

- 데이터 클래스 (Data Class)

  - 데이터 뭉치와 비슷하다

  - 데이터 클래스는 setter가 없는 불변성의 데이터 뭉치로 만들 건지,

  - 필요한 로직이 여기저기 있는지 확인해야 한다

- 상속 포기 (Refused Bequested)

  - 부모 클래스를 상속해서 부모 코드를 재사용하지만 불필요한 부모 코드가 많거나

  - 부모 코드는 필요한데 다른 인터페이스가 필요해서 상속을 필요해야하는 경우가 있다

  - 상속을 오용, 남용하는 것은 위험하다

  - 상속이 과연 필요한지 생각해야 한다

- 주석 (Comments)

  - 코드 자체를 설명하거나

  - 필요 없는 주석은 악이다
